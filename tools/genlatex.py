#print(" Pour que Ã§a marche il faut firefox et ajouter geckodriver soit dans PATH")
print("This python3 script requires the selenium geckodriver (https://selenium-python.readthedocs.io/installation.html#drivers)")
print("Other requirements: the in_place package")
print()



from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import UnexpectedAlertPresentException, NoAlertPresentException
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support.ui import WebDriverWait
from os.path import exists

import os
import os.path
import re
import in_place
import argparse

URL_YADE = os.getenv('YADE_URL')
if not URL_YADE:
    URL_YADE = 'https://amblafont.github.io/graph-editor/index.html'

DESCRIPTION = """
This script launches the diagram editor, inspects the given *main file* and waits 
until there is an *incomplete diagram*, that is, a *magic line* of the shape 
MAGIC_STRING [diagram] 
that is not followed by the list of lines (separated by \\n) specified by 
--prefix.

- MAGIC_STRING is the string specified by --magic
- [diagram] (optional) is a filename, or a json encoded diagram (pasted from the
  editor by using C-c  on some selected diagram, or from the content of a saved 
  file).
- empty lines are ignored in the process and lines are stripped for comparison

Then, the script loads the first incomplete diagram of the main file in the editor (or creates a new
one if the given filename does not exist, or the diagram was not provided) and waits until
the user saves the diagram. Then, it updates the magic line in the first line (i.e., 
update the json encoded diagram in case no filename was provided), adds the prefixes after the magic line, 
and then the latex generated by the diagram (or it writes it to an external file,
see options --external-tex and --include-cmd). Finally, it adds a list of lines specified
by --suffix.
"""

ID_SAVE_BUTTON = 'save-button'
ID_LOAD_BUTTON = 'load-button'
ID_SVG = 'canvas'



    
parser = argparse.ArgumentParser(description = DESCRIPTION, formatter_class=argparse.RawDescriptionHelpFormatter, prefix_chars='-+')
parser.add_argument("filename")
parser.add_argument("--make-cmd", help="make command to be executed")
parser.add_argument("--magic", default="% YADE DIAGRAM")
parser.add_argument("--prefix", default="% GENERATED LATEX")
parser.add_argument("--suffix", default="% END OF GENERATED LATEX")
parser.add_argument("--ext", default=".json")
parser.add_argument("--dir", default="", help="directory of diagram files")
parser.add_argument("--include-cmd", default="\\input{@}", help="use in combination with --external-tex")
parser.add_argument("--external-tex", action="store_true", help="For diagrams stored in an external file, this flag redirects the generated tex to an external file which is included with --include-cmd")

args = parser.parse_args()


filename = args.filename
makeCmd = args.make_cmd
magic = args.magic
prefixes = args.prefix.split("\\n")
suffixes = args.suffix.split("\\n")
basedir = args.dir
extension = args.ext
includecmd = args.include_cmd
externaltex = args.external_tex


# https://stackoverflow.com/questions/34795806/wait-until-alert-is-not-present-selenium-python
class alert_is_not_present(object):
    """ Expect an alert to not to be present."""
    def __call__(self, driver):
        try:
            alert = driver.switch_to.alert
            alert.text
            return False
        except NoAlertPresentException:
            return True



options = webdriver.FirefoxOptions()
options.unhandled_prompt_behavior = 'ignore'
browser = None 

def ctrlKey(actions,key):
    return actions.key_down(Keys.CONTROL).send_keys(key).key_up(Keys.CONTROL)


def waitUntilNoAlert():
    WebDriverWait(browser, 1000).until(alert_is_not_present())


def executeScriptIgnoreAlert(cmd):
    key = None
    while True:
      waitUntilNoAlert()
      try:
        key = browser.execute_async_script(cmd)
        break
      except UnexpectedAlertPresentException:
        continue
    return key


def parseMagic(line):
    search = re.search(re.escape(magic.strip()) + r"(.*)$", line.strip())
    if search:
        content = search.group(1).strip()
        return content
    else:
        return None

def parsePrefix(line, remainder):
    remainder = remainder.copy()
    if remainder == []:
        return []
    linestrip = line.strip()
    if linestrip == "":
        return remainder
    
    head = remainder.pop(0).strip()
    # remainder is now the tail
    if head == "":
        parsePrefix(linestrip, remainder)

    
    if linestrip == head:
        return remainder
    else:        
        return None

def focusSvg():
    browser.find_element(By.ID, ID_SVG).click()

def loadEditor(diag):
  stripped_diag = diag.strip()
  if (stripped_diag.strip() == ""):
      print("Creating new diagram")
      clear()
  else:
      print("Loading diagram ")
      cmd = 'sendGraphToElm('+ stripped_diag + ", 'python');"
      browser.execute_script(cmd)

def waitSaveDiag():
  print("Save to continue, Load to reload the file")
  return executeScriptIgnoreAlert('''  
     callback = arguments[arguments.length - 1];
     window.handleSave = callback;
  '''.format(idsave = ID_SAVE_BUTTON))


def genLatex():
  print("Exporting to latex")
  
  focusSvg()
  actions = ActionChains(browser)
  actions.move_to_element(browser.find_element(By.ID, ID_SVG)).move_by_offset(10,10).perform()
  ctrlKey(actions,'a').perform()
  browser.find_element(By.XPATH, '//button[text()="Export selection to quiver"]').click()
  # switch to new tab
  WebDriverWait(browser, 20).until(EC.number_of_windows_to_be(2))
  browser.switch_to.window(browser.window_handles[1])
  
  WebDriverWait(browser, 5).until(EC.invisibility_of_element((By.CSS_SELECTOR, "div.loading-screen")))
  el=WebDriverWait(browser, 5).until(EC.element_to_be_clickable((By.CSS_SELECTOR,"button[title='LaTeX']")))
  WebDriverWait(browser, 5).until(EC.invisibility_of_element((By.CSS_SELECTOR, "div.loading-screen")))
  el.click()
  el=WebDriverWait(browser, 5).until(EC.presence_of_element_located((By.CSS_SELECTOR,"div.code")))
  latex = el.text
  browser.close()
  browser.switch_to.window(browser.window_handles[0])
  return latex
    

def clear():
    browser.find_element(By.XPATH, '//button[text()="Clear"]').click()
    # To remove focus from the clear button:
    focusSvg()

def loadingScreen():
    diag = '{"graph":{"edges":[],"latexPreamble":"","nodes":[{"id":0,"label":{"isMath":false,"label":"Waiting for uncompleted diagrams in file {filename}","pos":[70,49.633331298828125]}}],"sizeGrid":200},"version":8}'
    cmd = 'sendGraphToElm('+ diag.replace("{filename}", filename) + ", 'python');"
    browser.execute_script(cmd)
    # To clear selection (don't know why sometimes stuff is selected after latex generation)
    focusSvg()

def handleFile():
    while handleFileOneIteration():
        pass

# return true if it should be recalled
def handleFileOneIteration():
    oldtimestamp = os.path.getmtime(filename)
    file = open(filename, 'r')
    
    remainder = []
    index = 0
    while remainder == []:
       line = ""
       content = None
       index = index + 1
       while content == None:
           line = file.readline()
           if line == "":
               # EOF
               break
           content = parseMagic(line)
    
       if content != None:
           print("graph found")  
       else:
           break 
       
       remainder = prefixes
       while remainder != None and remainder != []:
           line = file.readline()
           if line == "":
               # EOF
               break
           remainder = parsePrefix(line, remainder)
       if line == "":
          #EOF
          break
    file.close()
    if remainder != [] and content != None:
        print("do something with " + content)
        diagFile = None
        if contentIsFile(content):
           diagFile = content
           rfile = contentToFileName(diagFile)
           if exists(rfile):
             diagf = open(rfile,mode='r')
             content = diagf.read()
             diagf.close()
           else:
             content = ""
        loadEditor(content)
        newcontent = waitSaveDiag()
        newtimestamp = os.path.getmtime(filename)
        if newtimestamp != oldtimestamp or newcontent == None:
            ret = True
            if newcontent == None:
                print('reloading file')
            else:
                browser.execute_script("window.reponse = confirm('Main has file changed meanwhile. Do you wish to continue anyway?'); ")
                waitUntilNoAlert()
                ret = not browser.execute_script("return window.reponse;")
                
            focusSvg()
            if ret:
                return True
        latex = genLatex()
        if diagFile != None:
         wfile = contentToFileName(diagFile)
         print("writing to the file " + wfile)
         f = open(wfile, "w")
         f.write(newcontent)
         f.close()
         if externaltex:
            texFile = texFileName(diagFile) 
            print("writing tex file " + texFile)
            f = open(texFile, "w")
            f.write(latex)
            f.close()
            
        writeContent(newcontent, latex, index)

    return False


def contentIsFile(content):
    return content != "" and content.strip()[0] != "{"

def contentToFileName(content):
    return os.path.join(basedir, content + extension)

def texFileName(content):
    return os.path.join(basedir, content + ".tex")

def finish(fp):
    line = " "
    while line != "":
        line = fp.readline()
        fp.write(line)

def writeContent(newcontent, latex, index):
  with in_place.InPlace(filename) as fp:
     
      line = ""
      content = None
      for i in range(index):
         fp.write(line)
         content = None
         line = ""
         while content == None:
             fp.write(line)
             line = fp.readline()
             if line == "":
                 # EOF
                 break
             content = parseMagic(line)

      if content == None:
        print("Error")
        fp.write(line)
        finish(fp)   
        exit(-1)   
      if contentIsFile(content):
         fp.write(line)
         
        
      else:
         fp.write(magic + " " + newcontent + "\n")


      fp.write("\n".join(prefixes) + "\n")
      if not externaltex or not contentIsFile(content):
         fp.write(latex)
      else:
         fp.write(includecmd.replace("@", texFileName(content)))
      fp.write("\n"+"\n".join(suffixes)+"\n")
      finish (fp)

browser = webdriver.Firefox(options=options)
browser.set_script_timeout(84000)

browser.get(URL_YADE)
loadingScreen()
# This is useful in waitSaveDiag
browser.execute_script("""
     app.ports.saveGraph.unsubscribe(saveGraph);
     app.ports.saveGraph.subscribe(function(a) {{ window.handleSave(JSON.stringify(fromElmGraph(a))); }});
     document.getElementById('{idload}').onclick = function () {{ window.handleSave(); }};
""".format(idload = ID_LOAD_BUTTON))

browser.execute_script("window.onmouseover = function () { window.handleMovement(true); }; ")

while(True):
  
  handleFile()
  loadingScreen()  
  lastChange = os.path.getmtime(filename)
  currentChange = lastChange


  while lastChange == currentChange:
     d = executeScriptIgnoreAlert("window.handleMovement = arguments[arguments.length - 1];")
     currentChange = os.path.getmtime(filename)

