<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Main</title>
        <script>
            const renderedClass = "rendered-callback";
            const renderedEvent = "rendered";
        </script>
        <script src="elm.js"></script>
        
        <!-- The loading of KaTeX is deferred to speed up page rendering -->
        <script src="js/katex.min.css.js"></script>
        <script src="js/katex-custom-element.js"></script>
    <script onLoad="initKatex()" 
             defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>

       

             <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">

        
        <!-- Make foreignobject in svg visible -->
         <style>
          foreignObject { overflow:visible;
          /* to allow clicking through the overflow */
            pointer-events: none
          } 
          foreignObject * { 
              pointer-events: all;
          }
         .active-label { 
             border-color: red;
             border-style: solid;
             border-width: 1px;
             /* the outline is nice because it does not
             affect the width and height. Unfortunately,
             it does not behave nicely with \int_x */
             /* outline-style: solid; outline-color: red; */
             }
             /* selection rectangle */
             .rect-select {
                stroke: black;
                stroke-width: 1px;
                stroke-dasharray: 2;
                fill:transparent;
             }     
            .help-div {
                height: 5em;
                overflow: scroll;
            }
            path:hover {
                stroke-width : 4;
            }        
        </style> 
        <script>
            document.addEventListener("keydown", function(event)
            {
                // Tab key
                if (event.keyCode === 9)
                    event.preventDefault();
            }
            );
        </script>
    </head>

    <body>       
        <h1>Graph editor</h1>
   
     
        <p>
            A graph editor, with              
            (latex) labelled nodes and edges, tested with Firefox and Chrome.
        The code is available on
        <a href="https://github.com/amblafont/graph-editor-web">github</a>.
        </p>
        <button onclick="loadGraph()" >Load graph</button>
    <!--     <button onclick="dispatchRenderedChildren(document)">
            Recompute the layer
        </button> -->
        
        <!-- first use of katex element. It seems it should be done
        beforehand, otherwise dispatchRendered on the first labelled point  
        gets wrong dimensions.
        -->
        <math-latex> </math-latex>
        <div id="myapp"></div>
        <script>
         var appDiv = document.getElementById('myapp');
        
        
         
        function dispatchRendered(node) {            
            if (node.clientWidth != null)
                     {
                         // could be optimized by having an additionnal
                         // attribute that tells whether it has
                         // a listener
                         var rect = { width : node.clientWidth , height : node.clientHeight }
                         /* if (node.tagName = "MATH-LATEX") {
                            console.log (rect);
                            console.log (node.getBoundingClientRect());
                         } */
                         node.dispatchEvent(new CustomEvent(renderedEvent, { detail : rect } ));
                     }
        };

        function dispatchRenderedChildren(node) {
            children = node.getElementsByClassName(renderedClass);
                     for (var i = 0; i < children.length; ++i) {
                          dispatchRendered(children[i]);
                      }        
        }

         // rendered event handlers
         // Fonction callback à éxécuter quand une mutation est observée
         var callbackMutation = function(mutationsList) {
             for(var mutation of mutationsList) {
	               for(var node of mutation.addedNodes) {
             
                     dispatchRendered(node);
                     if (node.getElementsByClassName != null) {                                                  
                         dispatchRenderedChildren(node);  
                     }
                 }
                
	            /*    for(var node of mutation.removedNodes) {
                     if (node.getBoundingClientRect != null)
                     {
                         node.dispatchEvent(new CustomEvent("remove"));
                     }
                 } */
             }
         };

         // Créé une instance de l'observateur lié à la fonction de callback
         var observer = new MutationObserver(callbackMutation);
         observer.observe(appDiv, 
	                        { subtree: true, childList: true }); 

         // initialisation de Elm

         var app = Elm.Main.init({
             node: appDiv
         });
         // load a json graph file, send it to the elm component
         function loadGraph() {
             var input = document.createElement('input');
             input.type = 'file';
             input.accept = ".json";
             input.onchange = e => {
                 var file = e.target.files[0];
                 var fr=new FileReader();
                 fr.onload=function(){
                     var json = JSON.parse (fr.result);
                     app.ports.loadedGraph.send(json);
                 }
                 fr.readAsText(file);
             }

             input.click();
         };
         // this event handler computes the relative position
         // of the mouse with respect to the current target
         // (the one to which the event is attached)
         app.ports.onMouseMove.subscribe(function(e) {
             if ( e.currentTarget) {
                 var rect = e.currentTarget.getBoundingClientRect();
                 var x = e.clientX - rect.left; //x position within the element.
                 var y = e.clientY - rect.top;  //y position within the element.
                 app.ports.onMouseMoveFromJS.send([x, y]);
             }
         });
         // asks the user to download some file, generated from content
         function download(content, fileName, contentType) {
             var a = document.createElement("a");
             var file = new Blob([content], {type: contentType});
             a.href = URL.createObjectURL(file);
             a.download = fileName;
             a.click();
         }
         app.ports.saveGraph.subscribe(function(d) {
             download(JSON.stringify(d), 'graph.json', 'application/json');
         });
        </script>
    </body>
</html>
